// Conduit Turing-complete feature test
// Tests: Variables, Arithmetic, Conditionals, Loops, Functions, Recursion, State Mutation

// =========================================
// 1. VARIABLES AND ARITHMETIC
// =========================================

int global_counter = 0;

// =========================================
// 2. FUNCTIONS (Subroutines)
// =========================================

int add(int a, int b) {
    return a + b;
}

int subtract(int a, int b) {
    return a - b;
}

int multiply(int a, int b) {
    return a * b;
}

SafetyNet<int, DivideError> divide(int a, int b) {
    if (b == 0) {
        Caught DivideError.DivideByZero;
    }
    return a / b;
}

// =========================================
// 3. CONDITIONALS (Branching)
// =========================================

int absolute(int x) {
    if (x < 0) {
        return -x;
    } else {
        return x;
    }
}

int max(int a, int b) {
    if (a > b) {
        return a;
    }
    return b;
}

// =========================================
// 4. LOOPS (Iteration)
// =========================================

// While loop - sum from 1 to n
int sum_to_n(int n) {
    int mut sum = 0;
    int mut i = 1;

    while (i <= n) {
        sum = sum + i;
        i = i + 1;
    }

    return sum;
}

// For loop - factorial
int factorial_iterative(int n) {
    int mut result = 1;

    for (int i in 1..=n) {
        result = result * i;
    }

    return result;
}

// =========================================
// 5. RECURSION (Alternative to loops)
// =========================================

int factorial_recursive(int n) {
    if (n <= 1) {
        return 1;
    }
    return n * factorial_recursive(n - 1);
}

// Fibonacci - exponential recursion
int fibonacci(int n) {
    if (n <= 1) {
        return n;
    }
    return fibonacci(n - 1) + fibonacci(n - 2);
}

// =========================================
// 6. STATE MUTATION (Memory operations)
// =========================================

void increment_global() {
    mut global_counter;
    global_counter = global_counter + 1;
}

int get_global() {
    return global_counter;
}

// =========================================
// 7. ARRAYS (Indexed memory access)
// =========================================

int array_sum(&[int] arr) {
    int mut sum = 0;
    int mut i = 0;

    while (i < arr.length) {
        sum = sum + arr[i];
        i = i + 1;
    }

    return sum;
}

void array_fill(&!int[] arr, int value) {
    int mut i = 0;

    while (i < arr.length) {
        arr[i] = value;
        i = i + 1;
    }
}

// =========================================
// 8. COMPLEX STATE: STACK MACHINE
// =========================================
// Simulates a simple stack-based virtual machine

struct Stack {
    int[256] data
    int top
}

Stack stack_new() {
    return Stack {
        data: {0},  // Zero-initialized
        top: 0
    };
}

void stack_push(&!Stack stack, int value) {
    if (stack.top < 256) {
        stack.data[stack.top] = value;
        stack.top = stack.top + 1;
    }
}

SafetyNet<int, StackError> stack_pop(&!Stack stack) {
    if (stack.top > 0) {
        stack.top = stack.top - 1;
        return stack.data[stack.top];
    }
    Caught StackError.EmptyStack;
}

bool stack_is_empty(&Stack stack) {
    return stack.top == 0;
}

// =========================================
// 9. CONTROL FLOW: COLLATZ CONJECTURE
// =========================================
// Demonstrates complex conditional logic

SafetyNet<int, RuntimeError> collatz_steps(int n) {
    if (n <= 0) {
        Caught RuntimeError.InvalidInput;
    }

    int mut steps = 0;
    int mut current = n;

    while (current != 1) {
        if (current % 2 == 0) {
            current = current / 2;
        } else {
            current = current * 3 + 1;
        }
        steps = steps + 1;

        // Safety: prevent infinite loop
        if (steps > 10000) {
            Caught RuntimeError.TooManySteps;
        }
    }

    return steps;
}

// =========================================
// 10. TURING MACHINE SIMULATION
// =========================================
// Simulates a 2-state, 2-symbol busy beaver

enum TapeSymbol {
    Zero,
    One
}

enum State {
    A,
    B,
    Halt
}

enum error MachineError {
    OutOfBounds,
    InvalidState
}

struct TuringMachine {
    TapeSymbol[100] tape
    int head
    State state
    int steps
}

TuringMachine tm_new() {
    return TuringMachine {
        tape: {TapeSymbol.Zero},
        head: 50,  // Start in middle
        state: State.A,
        steps: 0
    };
}

void tm_step(&!TuringMachine tm) {
    if (tm.state == State.Halt) {
        return;
    }

    var current_symbol = tm.tape[tm.head];

    // Busy beaver 2-state transitions
    match (tm.state, current_symbol) {
        (State.A, TapeSymbol.Zero) => {
            tm.tape[tm.head] = TapeSymbol.One;
            tm.head = tm.head + 1;
            tm.state = State.B;
        }
        (State.A, TapeSymbol.One) => {
            tm.tape[tm.head] = TapeSymbol.Zero;
            tm.head = tm.head - 1;
            tm.state = State.B;
        }
        (State.B, TapeSymbol.Zero) => {
            tm.tape[tm.head] = TapeSymbol.One;
            tm.head = tm.head - 1;
            tm.state = State.A;
        }
        (State.B, TapeSymbol.One) => {
            tm.tape[tm.head] = TapeSymbol.One;
            tm.head = tm.head + 1;
            tm.state = State.Halt;
        }
        _ => { }
    }

    tm.steps = tm.steps + 1;
}

int tm_run(&!TuringMachine tm, int max_steps) {
    int mut i = 0;

    while (i < max_steps && tm.state != State.Halt) {
        tm_step(tm);
        i = i + 1;
    }

    return tm.steps;
}

// =========================================
// MAIN: RUN ALL TESTS
// =========================================

SafetyNet<(), RuntimeError> main() {
    #println("=== TURING COMPLETENESS TESTS ===\n");

    // Test 1: Basic arithmetic
    #println("1. Arithmetic:");
    #println("   5 + 3 = {}", add(5, 3));
    #println("   10 - 4 = {}", subtract(10, 4));
    #println("   6 * 7 = {}", multiply(6, 7));

    match divide(20, 4) {
        value => #println("   20 / 4 = {}\n", value),
        DivideError.DivideByZero => #println("   20 / 0 = Division by zero\n")
    }

    // Test 2: Conditionals
    #println("2. Conditionals:");
    #println("   abs(-42) = {}", absolute(-42));
    #println("   max(15, 23) = {}\n", max(15, 23));

    // Test 3: Loops
    #println("3. Loops:");
    #println("   sum(1..10) = {}", sum_to_n(10));
    #println("   factorial(5) = {}\n", factorial_iterative(5));

    // Test 4: Recursion
    #println("4. Recursion:");
    #println("   factorial_recursive(6) = {}", factorial_recursive(6));
    #println("   fibonacci(10) = {}\n", fibonacci(10));

    // Test 5: Global state mutation
    #println("5. State Mutation:");
    #println("   global_counter = {}", get_global());
    increment_global();
    increment_global();
    increment_global();
    #println("   after 3 increments = {}\n", get_global());

    // Test 6: Arrays
    #println("6. Arrays:");
    int[5] mut numbers = {1, 2, 3, 4, 5};
    #println("   array sum = {}", array_sum(&numbers));

    array_fill(&!numbers, 42);
    #println("   after fill(42) = {}\n", array_sum(&numbers));

    // Test 7: Stack machine
    #println("7. Stack Machine:");
    var mut stack = stack_new();
    stack_push(&!stack, 10);
    stack_push(&!stack, 20);
    stack_push(&!stack, 30);

    match stack_pop(&!stack) {
        value => #println("   pop = {}", value),
        StackError.EmptyStack => #println("   pop = Empty stack")
    }
    match stack_pop(&!stack) {
        value => #println("   pop = {}", value),
        StackError.EmptyStack => #println("   pop = Empty stack")
    }
    match stack_pop(&!stack) {
        value => #println("   pop = {}\n", value),
        StackError.EmptyStack => #println("   pop = Empty stack\n")
    }

    // Test 8: Complex control flow
    #println("8. Collatz Conjecture:");
    match collatz_steps(27) {
        steps => #println("   collatz(27) takes {} steps\n", steps),
        RuntimeError.InvalidInput => #println("   collatz() invalid input\n"),
        RuntimeError.TooManySteps => #println("   collatz() exceeded step limit\n")
    }

    // Test 9: Turing machine
    #println("9. Turing Machine (2-state Busy Beaver):");
    var mut tm = tm_new();
    var steps = tm_run(&!tm, 100);
    #println("   Halted after {} steps\n", steps);

    #println("=== ALL TESTS COMPLETE ===");

    return Ok(());
}
